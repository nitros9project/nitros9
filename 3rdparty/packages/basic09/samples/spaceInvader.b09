PROCEDURE spaceInvaderRUN foenix("CurOff")TYPE POINT=x,y:INTEGERTYPE REGION=max:POINTTYPE OBJECT=loc:POINT; look:STRING[5]; dead:BOOLEANDIM keyval:INTEGER \keyval=0DIM invader,defender,projectile:OBJECTDIM playingField:REGIONDIM score,points:INTEGER; key:STRING[1]READ playingField.max.x,playingField.max.yDATA 80,29READ defender.loc.x,defender.loc.yDATA 39,29READ defender.look,invader.look,projectile.lookDATA "/^\","(0)"," * "READ defender.dead,invader.dead,score,pointsDATA FALSE,TRUE,0,25LOOP IF invader.dead THEN invader.loc.x:=INT(RND(playingField.max.x))invader.loc.y:=INT(RND(playingField.max.y))invader.dead:=FALSEENDIF RUN foenix("Clear")RUN display(defender)RUN display(invader)RUN collisionCheck(invader,defender)IF defender.dead=TRUE THEN PRINT ""RUN foenix("Curon")ENDIF EXITIF defender.dead THEN ENDEXIT RUN foenix("Inkey",keyval)IF keyval=0 THEN GOSUB 100ELSE IF keyval=8 THEN GOSUB 200ENDIF IF keyval=9 THEN GOSUB 300ENDIF GOSUB 400keyval=0ENDIF ENDLOOP RUN foenix("Clear")PRINT "score = "; scoreEND 100 IF invader.loc.y<defender.loc.y THEN invader.loc.y:=invader.loc.y+1ENDIF RETURN 200 IF defender.loc.x>0 THEN defender.loc.x:=defender.loc.x-1ENDIF RETURN 300 IF defender.loc.x<playingField.max.x THEN defender.loc.x:=defender.loc.x+1ENDIF RETURN 400 IF defender.loc.x<>invader.loc.x THEN GOSUB 100ELSE projectile.loc.x:=invader.loc.x-1projectile.loc.y:=invader.loc.yRUN display(projectile)invader.dead:=TRUERUN nap(9)score:=score+pointsIF score<1000 THEN points:=points+pointsELSE invader.look:="\X/"ENDIF ENDIF RETURN PROCEDURE collisionCheckTYPE POINT=x,y:INTEGERTYPE OBJECT=loc:POINT; look:STRING[5]; dead:BOOLEANPARAM invader,defender:OBJECTIF invader.loc.y=defender.loc.y THEN IF ABS(invader.loc.x-defender.loc.x)<3 THEN defender.dead:=TRUEELSE invader.dead:=TRUEENDIF ENDIF PROCEDURE displayTYPE POINT=x,y:INTEGERTYPE OBJECT=loc:POINT; look:STRING[5]; dead:BOOLEANPARAM obj:OBJECTRUN foenix("CurXY",obj.loc.x,obj.loc.y)PRINT obj.look; PROCEDURE napTYPE REGISTERS=cc,a,b,dp:BYTE; x,y,u:INTEGERPARAM ticks:INTEGERDIM regs:REGISTERSDIM code:BYTEregs.x:=tickscode:=$0ARUN syscall(code,regs)